/*
已知一些 孩子 和一些 糖果 ，每个孩子有 需求因子 需求因子 需求因子 需求因子 g，每个糖果有 大小 s，当 某个糖果的大小 s >= 某个孩子 的需求因g时，代表该糖果可以满足孩子；求使用这 些糖果，最多能满足少孩子？ (注意，某个孩子最多只能用 1个糖果满足 )
例如，需求因子数组 g = [5, 10, 2, 9, 15, 9] ；糖果大小数组 s = [6, 1, 20, 3, 8] 最多 可以 满足 3个
1 某糖果不能满足某个孩子，则也不能满足需求更大的孩子
2 某孩子可以用更小的糖果满足，则没必要用更大的满足，保留更大糖果用来满足需求更大的孩子（贪心）
3 孩子需求更小更容易满足，故优先从需求因子小的孩子尝试

1 对需求因子g和糖果大小s进行从小到大排序
2 按照从小到大的顺序使用糖果尝试满足某个孩子，每个糖果尝试一次，成功则换下一个孩子尝试，直到发现没有更多孩子或没有更多糖果，循环结束
*/

class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        std::sort(g.begin(), g.end());  //对孩子的需求因子和糖果大小排序
        std::sort(s.begin(), s.end());
        int child = 0;  //已满足了几个孩子
        int cookie = 0;  //已尝试了几个糖果
        while(child < g.size() && cookie < s.size()){
            if(g[child] <= s[cookie]){
                child++;
            }
            cookie++;
        }
        return child;
    }
};

